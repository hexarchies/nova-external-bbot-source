#include "../Public/exploits.h"
#include "../Public/offsets.h"

bool exploits::Tick()
{
    static bool bResetSpinbot;
    static bool bResetWeaponSizeChanger;
    static bool bResetPlayerSizeChanger;
    static bool bResetPlayersSizeChanger;
    static bool bResetADS;

    if (cfg::RapidFire && cache::CurrentWeapon && cache::WeaponData) {
        float LastFireTime = memory::ReadMemory<float>(cache::CurrentWeapon + 0x760);
        memory::WriteMemory<float>(cache::CurrentWeapon + 0x760, LastFireTime - 2.f);
    }

    if (cfg::FullAutoWeapons && cache::WeaponData) {
        memory::WriteMemory<int>(cache::WeaponData + 0x9E0, 1);
    }

    if (cfg::NoRecoil && cache::PlayerController) {
        memory::WriteMemory<float>(cache::PlayerController + 0xC0, -1.f);
    }

    if (cfg::NoSpread && cache::CurrentWeapon) {
        memory::WriteMemory<float>(cache::CurrentWeapon + 0xC0, FLT_MAX);
    }

    if (cfg::ADSAir && cache::AcknowledgedPawn) {
        memory::WriteMemory<bool>(cache::AcknowledgedPawn + 0x24FD, true);

        if (!bResetADS)
            bResetADS = true;
    }
    else {
        if (bResetADS)
        {
            memory::WriteMemory<bool>(cache::AcknowledgedPawn + 0x24FD, false);
            bResetADS = false;
        }
    }

    if (cfg::Backtrack && cache::AimData.closestPawn) {
        static bool bResetMovement;
        if (GetAsyncKeyState(VK_TAB))
        {
            memory::WriteMemory<float>(cache::AimData.closestPawn + 0xC0, 0.f);

            if (!bResetMovement)
                bResetMovement = true;
        }
        else {
            if (bResetMovement)
            {
                memory::WriteMemory<float>(cache::AimData.closestPawn + 0xC0, 1.f);
                bResetMovement = false;
            }
        }
    }

    if (cfg::Spinbot && cache::Mesh && cache::AcknowledgedPawn) {
        static engine::vec3 orgin = { 0, 0, 0 };
        orgin.y += 100.f;
        memory::WriteMemory<engine::vec3>(cache::Mesh + offsets::RelativeRotation, orgin);

        if (!bResetSpinbot)
            bResetSpinbot = true;
    }
    else {
        if (bResetSpinbot)
        {
            memory::WriteMemory<engine::vec3>(cache::Mesh + offsets::RelativeRotation, engine::vec3(0, -90, 0));

            bResetSpinbot = false;
        }
    }
    static bool bResetFirstPerson;
    if (cfg::FirstPerson && cache::PlayerCameraManager && cache::AcknowledgedPawn) {
        memory::WriteMemory<bool>(cache::PlayerController + 0xB28 + 0x10 + 0x18, true);

        if (!bResetFirstPerson)
            bResetFirstPerson = true;
    }
    else {
        if (bResetFirstPerson)
        {
            memory::WriteMemory<bool>(cache::PlayerController + 0xB28 + 0x10 + 0x18, false);
            bResetFirstPerson = false;
        }
    }
    static bool bResetFOVChanger;
    if (cfg::FovChanger && cache::PlayerCameraManager && cache::AcknowledgedPawn) {
        memory::WriteMemory<float>(cache::PlayerCameraManager + offsets::DefaultFOV, cfg::FovChangerScale);

        if (!bResetFOVChanger)
            bResetFOVChanger = true;
    }
    else {
        if (bResetFOVChanger)
        {
            memory::WriteMemory<float>(cache::PlayerCameraManager + offsets::DefaultFOV, 90.f);
            bResetFOVChanger = false;
        }
    }

    if (cfg::InstaRevive && cache::Mesh && cache::AcknowledgedPawn) {
        memory::WriteMemory<float>(cache::AcknowledgedPawn + 0x2178, 1.f);
    }

    if (cfg::PlayerFly && cache::AcknowledgedPawn) {
        memory::WriteMemory<bool>(cache::AcknowledgedPawn + 0x1240 + 0x8, true);
    }

    if (cfg::AirStuck && cache::Mesh && cache::AcknowledgedPawn)
    {
        if (GetAsyncKeyState(VK_SHIFT)) {
            memory::WriteMemory<float>(cache::AcknowledgedPawn + 0xC0, 0.f);
        }
        else {
            memory::WriteMemory<float>(cache::AcknowledgedPawn + 0xC0, 1.f);
        }
    }

    if (cfg::NoMinigunCooldown && cache::CurrentWeapon && cache::AcknowledgedPawn) {
        float TimeHeatWasLastAdded = memory::ReadMemory<float>(cache::CurrentWeapon + offsets::TimeHeatWasLastAdded);
        if (TimeHeatWasLastAdded != 0.f) {
            memory::WriteMemory<float>(cache::CurrentWeapon + offsets::TimeHeatWasLastAdded, 0.f);
        }

        float TimeOverheatedBegan = memory::ReadMemory<float>(cache::CurrentWeapon + offsets::TimeOverheatedBegan);
        if (TimeOverheatedBegan != 0.f) {
            memory::WriteMemory<float>(cache::CurrentWeapon + offsets::TimeOverheatedBegan, 0.f);
        }

        float OverheatValue = memory::ReadMemory<float>(cache::CurrentWeapon + offsets::OverheatValue);
        if (OverheatValue != 0.f) {
            memory::WriteMemory<float>(cache::CurrentWeapon + offsets::OverheatValue, 0.f);
        }


        float WeaponOverheatedAnimation = memory::ReadMemory<float>(cache::CurrentWeapon + offsets::WeaponOverheatedAnimation);
        if (WeaponOverheatedAnimation != 0.f) {
            memory::WriteMemory<float>(cache::CurrentWeapon + offsets::WeaponOverheatedAnimation, 0.f);
        }
    }

    if (cfg::DoublePump && cache::CurrentWeapon && cache::AcknowledgedPawn) {
        bool bIgnoreTryToFireSlotCooldownRestriction = memory::ReadMemory<bool>(cache::CurrentWeapon + offsets::bIgnoreTryToFireSlotCooldownRestriction);
        if (bIgnoreTryToFireSlotCooldownRestriction != true)
        {
            memory::WriteMemory<bool>(cache::CurrentWeapon + offsets::bIgnoreTryToFireSlotCooldownRestriction, true);
        }
    }

    if (cfg::ChangeWeaponMesh && cache::WeaponMesh)
    {
        memory::WriteMemory<engine::vec3>(cache::WeaponMesh + 0x17C, { cfg::WeaponMeshScale, cfg::WeaponMeshScale, cfg::WeaponMeshScale });

        if (!bResetWeaponSizeChanger)
            bResetWeaponSizeChanger = true;
    }
    else {
        if (bResetWeaponSizeChanger)
        {
            memory::WriteMemory<engine::vec3>(cache::WeaponMesh + 0x17C, { 1.f, 1.f, 1.f });
            bResetWeaponSizeChanger = false;
        }
    }

    if (cfg::ChangePlayerMesh && cache::Mesh)
    {
        memory::WriteMemory<engine::vec3>(cache::Mesh + 0x17C, { cfg::PlayerMeshScale, cfg::PlayerMeshScale, cfg::PlayerMeshScale });

        if (!bResetPlayerSizeChanger)
            bResetPlayerSizeChanger = true;
    }
    else {
        if (bResetPlayerSizeChanger)
        {
            memory::WriteMemory<engine::vec3>(cache::Mesh + 0x17C, { 1.f, 1.f, 1.f });
            bResetPlayerSizeChanger = false;
        }
    }
    if (cfg::ChangePlayersMesh && cache::Mesh)
    {
        memory::WriteMemory<engine::vec3>(cache::PlayersMesh + 0x17C, { cfg::PlayersMeshScale, cfg::PlayersMeshScale, cfg::PlayersMeshScale });

        if (!bResetPlayersSizeChanger)
            bResetPlayersSizeChanger = true;
    }
    else {
        if (bResetPlayersSizeChanger)
        {
            memory::WriteMemory<engine::vec3>(cache::PlayersMesh + 0x17C, { 1.f, 1.f, 1.f });
            bResetPlayersSizeChanger = false;
        }
    }
    return true;
}
